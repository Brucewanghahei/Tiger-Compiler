structure A = Absyn
type symbol = A.symbol

datatype lvalueVar_t = Field of symbol
                     | Subscript of A.exp

fun buildLvalueVar(v, lst, pos) =
    case lst of
        hd::tl => (case hd of
                       Field(symbl) => buildLvalueVar(A.FieldVar(v, symbl, pos), tl, pos)
                     | Subscript(exp) => buildLvalueVar(A.SubscriptVar(v, exp, pos), tl, pos))
      | nil => v

%%
%term
    EOF 
  | ID of string
  | INT of int | STRING of string 
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK 
  | LBRACE | RBRACE | DOT 
  | PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF 
  | BREAK | NIL
  | FUNCTION | VAR | TYPE 
  | UMINUS

%nonterm  exp | program of A.exp | expseq | expseq_list | decs | dec | tydec | ty | record_ty | tyfields | tyfields_list | array_ty | vardec | fundec | lvalue | lvalue_list | record_fields | record_fields_list | cop | aop | param_list | param_list_list
     
%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE 
	DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

(* here goes the precedence *)
%nonassoc DO OF THEN ASSIGN
%nonassoc IF
%nonassoc ELSE
%left OR
%left AND
%nonassoc EQ NEQ LT LE GT GE
%left PLUS MINUS
%left TIMES DIVIDE
%nonassoc UMINUS

%%

program	: exp				()
exp:
    (* let_exp *)
    LET decs IN expseq END (A.LetExp {decs = decs, body = A.SeqExp expseq, pos = LETleft})
    (* break_exp *)
    | BREAK (A.BreakExp BREAKleft)
    (* for_exp *)
    | FOR ID ASSIGN exp TO exp DO exp (A.ForExp {var = symbol ID, escape = ref false, lo = exp1, hi = exp2, body = exp3, pos = FORleft})
    (* while_exp *)
    | WHILE exp DO exp (A.WhileExp {test = exp1, body = exp2, pos = WHILEleft})
    (* if_then_exp *)
    | IF exp THEN exp (A.IfExp {test = exp1, then' = exp2, else' = A.NilExp, pos = IFleft})
    (* if_then_else_exp *)
    | IF exp THEN exp ELSE exp (A.IfExp {test = exp1, then' = exp2, else' = exp3, pos = IFleft})
    (* assign_exp *)
    | lvalue ASSIGN exp (A.AssignExp {var = lvalue, exp = exp, pos = lvalueleft})
    (* array_exp *)
    | ID LBRACK exp RBRACK OF exp ()
    (* record_exp *)
    | ID LBRACE record_fields RBRACE ()
    (* comp_exp : exp cop exp () *)
    | exp EQ exp ()
    | exp NEQ exp ()
    | exp LT exp ()
    | exp GT exp ()
    | exp LE exp ()
    | exp GE exp ()
    (* arith_exp : exp aop exp () *)
    | exp PLUS exp ()
    | exp MINUS exp ()
    | exp TIMES exp ()
    | exp DIVIDE exp ()
    | MINUS exp %prec UMINUS ()
    (* func_call_exp *)
    | ID LPAREN param_list RPAREN ()
    | LBRACE expseq RBRACE ()
    | NIL (A.NilExp)
	    
expseq : exp expseq_list ()
       | ()
expseq_list : SEMICOLON expseq ()
	    | ()
	      
decs : dec decs ()
     | ()
dec : tydec ()
    | vardec ()
    | fundec ()
tydec : TYPE ID EQ ty ()
ty : ID ()
   | record_ty ()
   | array_ty ()
record_ty : LBRACE tyfields RBRACE ()
tyfields : ID COLON ID tyfields_list ()
	 | ()
tyfields_list : COMMA tyfields ()
	  | ()
array_ty : ARRAY OF ID ()
vardec : VAR ID ASSIGN exp ()
       | VAR ID COLON ID ASSIGN exp ()
fundec : FUNCTION ID LPAREN tyfields RPAREN EQ exp ()
       | FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ exp ()

lvalue : ID lvalue_list ()
lvalue_list : DOT ID lvalue_list ()
	| LBRACK exp RBRACK lvalue_list ()
	| ()

record_fields : ID EQ exp record_fields_list ()
record_fields_list : COMMA record_fields ()
		   | ()

param_list : exp param_list_list ()
param_list_list : COMMA param_list ()
		| ()

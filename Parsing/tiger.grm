structure A = Absyn
type symbol = A.symbol

datatype lvalueVar_t = Field of symbol
                     | Subscript of A.exp

fun buildLvalueVar(v, lst, pos) =
    case lst of
        hd::tl => (case hd of
                       Field(symbl) => buildLvalueVar(A.FieldVar(v, symbl, pos), tl, pos)
                     | Subscript(exp) => buildLvalueVar(A.SubscriptVar(v, exp, pos), tl, pos))
      | nil => v

fun buildBinOpExp(lhs, op, rhs, pos) =
    A.OpExp {left = lhs, oper = op, right = rhs, pos = pos}

fun buildIfExp(test, thenExp, elseExp, pos) =
    A.IfExp(test = test, then' = thenExp, else' = elseExp, pos = pos)

fun buildTypeField(name, typ, pos) =
    A.field {name = name, escape = ref false, typ = typ, pos = pos}

fun buildVarDec(name, escapse, typ, init, pos) =
    A.VarDec {name = name, escape = escape, typ = typ, init = init, pos = pos}

fun buildFunDec(name, params, result, body, pos) =
    A.fundec {name = name, params = params, result = result, body = body, pos = pos}

%%
%term
    EOF 
  | ID of string
  | INT of int | STRING of string 
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK 
  | LBRACE | RBRACE | DOT 
  | PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF 
  | BREAK | NIL
  | FUNCTION | VAR | TYPE 
  | UMINUS

%nonterm  exp | program of A.exp | expseq | expseq_list | decs | dec | tydec | ty | record_ty | tyfields | tyfields_list | array_ty | vardec | fundec | lvalue | lvalue_list | record_fields | record_fields_list | cop | aop | param_list | param_list_list
     
%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE 
	DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

(* here goes the precedence *)
%nonassoc DO OF THEN ASSIGN
%nonassoc IF
%nonassoc ELSE
%left OR
%left AND
%nonassoc EQ NEQ LT LE GT GE
%left PLUS MINUS
%left TIMES DIVIDE
%nonassoc UMINUS

%%

program	: exp				()
exp:
    (* let_exp *)
    LET decs IN expseq END (A.LetExp {decs = decs, body = A.SeqExp expseq, pos = LETleft})
    (* break_exp *)
    | BREAK (A.BreakExp BREAKleft)
    (* for_exp *)
    | FOR ID ASSIGN exp TO exp DO exp (A.ForExp {var = symbol ID, escape = ref false, lo = exp1, hi = exp2, body = exp3, pos = FORleft})
    (* while_exp *)
    | WHILE exp DO exp (A.WhileExp {test = exp1, body = exp2, pos = WHILEleft})
    (* if_then_exp *)
    | IF exp THEN exp (buildIfExp(exp1, exp2, NONE, IFleft))
    (* if_then_else_exp *)
    | IF exp THEN exp ELSE exp (buildIfExp(exp1, exp2, SOME exp3, IFleft))
    (* assign_exp *)
    | lvalue ASSIGN exp (A.AssignExp {var = lvalue, exp = exp, pos = lvalueleft})
    (* array_exp *)
    | ID LBRACK exp RBRACK OF exp (A.ArrayExp {typ = symbol ID, size = exp1, init = exp2, pos = IDleft})
    (* record_exp *)
    | ID LBRACE record_fields RBRACE (A.RecordExp {fields = record_fields, typ = symbol ID, pos = IDleft})
    (* comp_exp : exp cop exp () *)
    | exp EQ exp (buildBinOpExp(exp1, A.EqOp, exp2, exp1left))
    | exp NEQ exp (buildBinOpExp(exp1, A.NeqOp, exp2, exp1left))
    | exp LT exp (buildBinOpExp(exp1, A.LtOp, exp2, exp1left))
    | exp GT exp (buildBinOpExp(exp1, A.GtOp, exp2, exp1left))
    | exp LE exp (buildBinOpExp(exp1, A.LeOp, exp2, exp1left))
    | exp GE exp (buildBinOpExp(exp1, A.GeOp, exp2, exp1left))
    (* logic_exp: exp lop exp *)
    | exp AND exp (buildIfExp(exp1, exp2, SOME 0, exp1left))
    | exp OR exp (buildIfExp(exp1, SOME 1, exp2, exp1left))
    (* arith_exp : exp aop exp () *)
    | exp PLUS exp (buildBinOpExp(exp1, A.PlusOp, exp2, exp1left))
    | exp MINUS exp (buildBinOpExp(exp1, A.MinusOp, exp2, exp1left))
    | exp TIMES exp (buildBinOpExp(exp1, A.TimesOp, exp2, exp1left))
    | exp DIVIDE exp (buildBinOpExp(exp1, A.DivideOp, exp2, exp1left))
    | MINUS exp %prec UMINUS (buildBinOpExp(A.IntExp 0, A.MinusOp, exp, MINUSleft))
    (* func_call_exp *)
    | ID LPAREN param_list RPAREN (A.CallExp {func = symbol ID, args = param_list, pos = IDleft})
    | LPAREN expseq RPAREN (A.SeqExp expseq)
    | NIL (A.NilExp)
	    
expseq : exp expseq_list ([(exp, expleft)] @ expseq_list)
       | (nil)
expseq_list : SEMICOLON exp expseq_list ([(exp, SEMICOLONleft)] @ expseq_list)
	    | (nil)
	      
decs : dec decs ([dec] @ decs)
     | (nil)
dec : tydec (A.TypeDec tydec)
    | vardec (vardec)
    | fundec (A.FunctionDec fundec)
tydec : TYPE ID EQ ty ({name = sylbol ID, ty = ty, pos = TYPEleft})
ty : ID (A.NameTy(symbol ID, IDleft))
   | record_ty (A.RecordTy record_ty)
   | array_ty (A.ArrayTy array_ty)
record_ty : LBRACE tyfields RBRACE (tyfields)
tyfields : ID COLON ID tyfields_list ([buildTypeField(ID1, ID2, IDleft1)] @ typefields_list)
	 | (nil)
tyfields_list : COMMA ID COLON ID tyfields_list ([buildTypeField(ID1, ID2, COMMAleft)] @ typefields_list)
	  | (nil)
array_ty : ARRAY OF ID ((symbol ID, ARRAYleft))
vardec : VAR ID ASSIGN exp (buildVarDec(symbol ID, ref false, NONE, exp, VARleft))
       | VAR ID COLON ID ASSIGN exp (buildVarDec(symbol ID1, ref false, SOME ID2, exp, VARleft))
fundec : FUNCTION ID LPAREN tyfields RPAREN EQ exp (buildFunDec(symbol ID, tyfields, NONE, exp, FUNCTIONleft))
       | FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ exp (buildFunDec(symbol ID1, tyfields, SOME ID2, exp, FUNCTIONleft))

lvalue : ID lvalue_list ()
lvalue_list : DOT ID lvalue_list ()
	| LBRACK exp RBRACK lvalue_list ()
	| ()

record_fields : ID EQ exp record_fields_list ()
record_fields_list : COMMA record_fields ()
		   | ()

param_list : exp param_list_list ()
param_list_list : COMMA param_list ()
		| ()
